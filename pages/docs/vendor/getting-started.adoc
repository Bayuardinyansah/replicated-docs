= Getting started

:page-slug: /docs/vendor/getting-started/
:page-order: 0
:page-section: Vendor

= Packaging an application

Software vendors with a Kubernetes application can package their app as a Kubernetes-off-The-Shelf (KOTS) software for distribution to enterprise customers as a modern on-prem, private instance.
The packaging process leverages several KOTS components (some optional, some required).
For context, Replicated KOTS is made of several purpose built, open source components, but should be thought of in two distinct (but highly integrated) categories.

* **Cluster Operator Tools**: A set of open source projects that KOTS vendors can invoke to provide cluster operators with the necessary tools to validate, install, configure, troubleshoot, and automate the management of the KOTS application.
These tools are built with a strong focus on production grade day-2 operations.
* **Software Vendor Tools**: Primarily provided by a hosted https://vendor.replicated.com[Vendor Portal] that serves as a centralized collaboration platform to manage customers, licenses/entitlements, releases/release channels, and troubleshooting. The vendor tools are https://blog.replicated.com/announcing-kots/[deeply integrated with the OSS KOTS projects] to provide processes and workflows to operationalize and scale the distribution of a modern on-prem application.

The foundational open source projects that KOTS coordinates are https://kots.io[Replicated Kots CLI and Kotsadm] (installation and admin console), https://troubleshoot.sh[Replicated Troubleshoot] (preflight checks and support bundles), https://kurl.sh[Replicated kURL] (embedded K8s option) as well as several community driven OSS projects like Kubernetes, Kustomize, Helm, and Kubeadm.

This document starts with an overview on how to package and manage KOTS applications via the Replicated Vendor Portal (an API and CLI are available for more rapid or automated iteration).
Please refer to our documentation of the [Kots CLI](/kots-cli/getting-started/) to install and manage a KOTS application via the command line, or our [Kotsadm documentation](/kotsadm/installing/installing-a-kots-app/) for managing an application via the admin console.

== Getting Started as a KOTS Vendor
It's easy to get started packaging an app in KOTS.
To start, create a Replicated Vendor account at our [Vendor Portal](https://vendor.replicated.com) and follow one of our [Getting Started Guides](/vendor/guides/).

== Basic Packaging
KOTS applications are packaged as a set of standard Kubernetes manifests.
These manifests include your application manifests, plus several optional [KOTS custom resources](/vendor/packaging/kots-custom-resources/) used to invoke various KOTS functions.
Together, these manifests can be managed via [release channels](/vendor/packaging/channels-and-releases), and delivered to customers by providing [installation instructions](/kotsadm/installing/installing-a-kots-app/), and a Replicated generated [license](/vendor/packaging/customers-and-licenses).

Most applications require some amount of customer supplied configuration values.
These values can be collected during the installation process by specifying a [config KOTS custom resource](/reference/v1beta1/config) to [create a config screen](/vendor/config/config-screen/), and provided to the application by [templating your Kubernetes manifests](/vendor/packaging/template-functions).

== Helm Chart Packaging
If your application is already templated and packaged as a Helm chart (or includes Helm charts), then you can follow our documentation on [packaging a Helm chart as a KOTS application](/vendor/helm/using-helm-charts/).

== Advanced Features
KOTS vendors can invoke several other more advanced features by providing additional KOTS custom resources.
For customizable Preflight checks, vendors can provide a [preflight custom resource](/reference/v1beta1/preflight/) in order to test a cluster for necessary resources or other dependencies, and show warnings or errors if the target cluster fails any of these checks.
Similarly, troubleshooting features can be enabled by creating [collector and analyzer](/reference/v1beta1/support-bundle) custom resources.
Finally, the [Application](/reference/v1beta1/application) and [sig-application](/reference/v1beta1/sig-application) custom resources provide branding metadata (icon, title, descriptions, etc...), readiness checks, and end-user links, enabling the Admin Console to show application health and readiness, and launch the app once it's ready.

KOTS licenses are created and managed through the Replicated https://vendor.replicated.com[Vendor Portal], which provides support for configurable pre-built entitlements, expiration dates, license types and a framework for delivering custom entitlements (seat count, etc). See the [entitlements documentation](/vendor/entitlements/entitlements/) for more information.


= KOTS custom resources

A KOTS application can include several recommended, but optional [KOTS custom resources](/reference/v1beta1/).
These custom resources are packaged as part of the KOTS application, but are not deployed to the cluster.
When included, they are consumed by KOTS, the Admin Console, or by other kubectl plugins to control the KOTS application experience.

When viewing a release in the https://vendor.replicated.com/releases/[Vendor Portal], the KOTS custom resources are grouped together at the top of the manifests list.
![](/images/kots-custom-resources.png)

For more information on each of the custom resources, see the [reference section](/reference/v1beta1/), or check out the spec for a custom resource: [Config](/reference/v1beta1/config/), [Application](/reference/v1beta1/application), [Preflight](/reference/v1beta1/preflight), [Analyzer](https://troubleshoot.sh/reference/analyzers/overview/), [Collector](https://troubleshoot.sh/reference/collectors/overview/), [Sig-Application](/reference/v1beta1/sig-application), [HelmChart](/reference/v1beta1/helmchart/).


= Channels and releases

The Replicated https://vendor.replicated.com[vendor portal] provides you with a location to create and release versions of your application to various release channels.
The vendor portal hosts a built-in YAML editor and linter to help you write and validate YAML.

== Promoting Releases
Once a release is ready to be installed, the release can be promoted to one or more release channels.
More details can be found in our [Promote Releases documentation](/vendor/packaging/promoting-releases).

== Manage Release Channels
By default, there are 3 release channels: Stable, Beta and Unstable. When you first log in to Replicated and select the Channels tab, you’ll see these default release channels created.
You can delete, edit, or create new channels at any time.
The channels Replicated creates by default are commonly used for:

=== Unstable
The Unstable channel is designed for you to constantly push releases to, much in the same way that you continuously deploy new versions to your cloud product.
This is the channel that your development environment should have a license assigned to.
This channel is designed to be internal and for testing, not for your customers to be licensed against.

=== Beta
The Beta channel is created for release candidates and early adopting customers.
We recommend you promote a release to the Beta channel once it’s passed automated testing in the Unstable channel.
You can also choose to license some early-adopting customers against this channel.

=== Stable
For most of your customers, you will create a license that assigns them to the Stable channel.
By doing so, they’ll only receive updates when you push a new version to this channel.


= Customers and licenses

Each customer you deploy to via, Replicated will need a separate license file for their installation.
This license file identifies the customer & application during the installation and update processes.
A customer license is created in the Customers section of the [vendor portal](https://vendor.replicated.com). You can manage the values and properties of that customer and license, including custom license fields, by selecting an individual customer.

If you are looking to create or manage custom license fields, you can do so in the License Fields section of the vendor portal, described in greater detail in the [Custom Entitlements](/vendor/entitlements/custom-entitlements) section.

== Name (Required)
The name of the customer to whom this license is assigned.

== Channel (Required)
When you create a license, you’ll need to assign it to at least one release channel.
The Stable channel is intended to be used for production installations.
Unstable and Beta channels are intended for internal testing.

When a license is assigned to multiple channels, the customer will be able to select the channel at install time, and later change the release channel in the management console.
For airgapped installs, the channel can be selected at download time only.

== Expiration Date
When you create a license, you can specify an expiration date. By default an application with an expired license will continue to run, but will be prevented from receiving updates.

However applications can be instrumented to implement custom behavior by reading the license values and employing custom application logic based on the values for the `expires_at` license field.

== Airgap Download Enabled
By default, licenses will be set to disable airgapped installations.
By enabling this feature, the actual .rli file will have license meta data embedded in it, and must be re-downloaded.

== License Type (Required)
It is important to identify the type of license that is being created: development, trial or paid.
Development licenses are designed to be used internally by the development team for testing and integration.
Trial licenses should be provided to customers who are on 2-4 week trials of your software.
Paid licenses identify the end customer as a paying customer (for which additional information can be provided.)

== Custom License Fields
Custom license fields can be set for all licenses.
This is useful if specific customer information might change from customer to customer.
These fields can be read from both the template functions, as well as from Admin Console API.
Examples of custom license fields are “seats” to limit the number of active users, or “hostname” in order to specify the domain that the application can be run on.
See the [Custom Entitlements](/vendor/entitlements/) section for more details.

== Archiving Licenses
When a license is archived in the vendor portal, it will be hidden in the default license search and become read-only.
Archival does not affect the utility of license files downloaded before the change.
If you wish for them to expire, set an expiration date and policy before archiving.
This is a convenience feature for how licenses are displayed in the vendor portal.


= Promoting releases

Every Replicated license points to a Release Channel.
When a license is installed, it will pull down and install the release that is currently at the top of its channel.
It’s recommended to create customer licenses on the Stable channel, and only promote releases to Stable that are ready for all customers to install.

Once an application is installed, the active instance can be updated by promoting a release to the channel that instance is licensed to (likely Stable).
Each instance will periodically check for new releases.
When a new release is found, the Replicated installation will show a button that allows end customers managing the instance to read the release notes and install the update.
A license only checks it’s own release channel.

To promote a release, you can use the https://vendor.replicated.com[vendor portal], and click **Promote**:

images::promote-button.png[Promote Button]

When a release is promoted it should be given a version label and detailed release notes.
The release notes support markdown and will be shown to your customer.
Additionally, each promoted release must be given a required status (required or not required).

== Notes

- Before you can create or install a license, a release must be promoted to the channel.
- Update checking defaults to every 15 minutes but can be configured by end customers.
- It is possible to change a license value to have updates automatically installed when detected by the running instance.
- License values are synced with the values set in the vendor portal when the customer syncs the license.
- Releases will not be editable after being promoted to a channel.
- Release notes, version numbers, and the required status may be edited after promotion by visiting the channel’s history.


= Embedded Kubernetes

A KOTS application can be deployed to an existing cluster, or the installer can provision a new cluster with the application.

Check out our overview of delivering an embedded Kubernetes installer with your application: https://blog.replicated.com/kurl-with-replicated-kots/[using kURL with Replicated KOTS].



= Private images

When building your application, you have the option to use the Replicated private registry or any supported external private or public registry.

== External Registry Support

When packaging and delivering an enterprise application, a common problem is the need to include private Docker images.
Most enterprise applications consist of public images (postgres, mysql, redis, elasticsearch) and private images (the application images).

When delivering a KOTS application through https://vendor.replicated.com[vendor.replicated.com], there’s built-in support to include private images -- without managing or distributing actual registry credentials to your customer.
The license file grants revokable image pull access to private images, whether these are stored in the Replicated private registry, or another private registry server that you’ve decided to use.

If your application images are already available in a private, but accessible image registry (such as Docker Hub, quay.io, ECR, GCR, Artifactory or such), then your application licenses can be configured to grant proxy, or pull-through access to the assignee without giving actual credentials to the customer.

This is useful and recommended because it prevents you from having to modify the process you use to build and push application images, and it gives you the ability to revoke a customer’s ability to pull (such as on trial expiration).
This External Registry is shared across all KOTS applications in a team, allowing images to be used across multiple apps.

To configure access to your private images, log in to https://vendor.replicated.com[vendor.replicated.com], and click on the images menu item under your application.
Here, there’s a button named **Add External Registry**.
Fill this modal out with an endpoint (quay.io, index.docker.io, gcr.io, etc) and provide a username and password to Replicated that has pull access.
For more information, see the documentation on our registry.
Replicated will store your username and password encrypted and securely, and it (and the encryption key) will never leave our servers.

images::add-external-registry.png[Add External Registry]

Your application YAML will reference images that it cannot access.
KOTS recognizes this, and will patch the YAML using Kustomize to change the image name.
When KOTS is attempting to install an application, it will attempt to load image manifest using the image reference from the PodSpec.
If it’s loaded successfully, no changes will be made to the application.
If a 401 is received and authentication is required, KOTS will assume that this is private image that needs to be proxied through the Replicated registry-proxy service.
A patch will be written to the midstream kustomization.yaml to change this image name during deployment.

For example, given a private image hosted at `quay.io/my-org/api:v1.0.1`, a deployment and pod spec may reference it like this:

[source,YAML]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: example
spec:
  template:
    spec:
      containers:
        - name: api
          image: quay.io/my-org/api:v1.0.1
----

When the application is deployed, KOTS will detect that it cannot access the image at quay.io and will create a patch in the `midstream/kustomization.yaml`:

[source,YAML]
----
apiVersion: kustomize.config.k8s.io/v1beta1
bases:
- ../../base
images:
- name: quay.io/my-org/api:v1.0.1
  newName: proxy.replicated.com/proxy/my-kots-app/quay.io/my-org/api
----

This will change that image name everywhere it appears.

In addition, KOTS will create an imagePullSecret dynamically and automatically at install time.
This secret is based on the customer license, and will be used to pull all images from `proxy.replicated.com`

Images hosted at `registry.replicated.com` will not be rewritten.
However, the same secret will be added to those PodSpecs as well.

> KOTS [Application](/reference/v1beta1/application/) deployments are supported via image tags in all use cases. KOTS has limited support for deploying via image digests. Use of image digests are only supported for fully online installs where all images can be pulled from the Replicated registry, a public repo, or proxied from a private repo via the Replicated registry.

== Replicated Private Registry

When using the Replicated Private Registry, you have 2 options to connect with the `registry.replicated.com` container registry:
* Use `docker login registry.replicated.com` with your Vendor portal email and password credentials
* Use `docker login registry.replicated.com` with a Vendor Portal [API token](/vendor/guides/cli-quickstart/#2-setting-a-service-account-token) for both username and password.

Once logged in, you will need to tag your image. Replicated accepts images in the standard Docker format: `registry.replicated.com/<application-slug>/<image-name>:<version>`. You can find your application slug on the Images page of the [Replicated Vendor Portal](https://vendor.replicated.com/#/images).

An example of tagging an existing image is:

[source,terminal]
----
$ docker tag worker registry.replicated.com/myapp/worker:1.0.1
----

Once the image is tagged you can use `docker push` to push your private image to the Replicated private registry:
[source,terminal]
----
$ docker push registry.replicated.com/app-slug/image:tag
----

For more information about building, tagging and pushing docker images, see the https://docs.docker.com/engine/reference/commandline/cli/[Docker CLI Documentation].

== Additional namespaces

When deploying pods to namespaces other than the KOTS application namespace, the namespace must be added to the `additionalNamespaces` attribute of the [Application](/reference/v1beta1/application/) spec.
This will ensure that the application image pull secret will get auto-provisioned by KOTS in the namespace to allow the pod to pull the image.
For more information about the `additionalNamespaces` attribute see [this doc](/vendor/operators/additional-namespaces/).


= Template functions

KOTS applications have access to a rich set of template functions that can be used to render the Kubernetes manifests in the customer's environment.

KOTS uses Go's https://golang.org/pkg/text/template/[text/template] libraries as the basis for the templating. All functionality of Go's templating language can be used in conjuction with KOTS custom functions.

All template functions are documented in the [template function reference](/reference/template-functions) section of these docs.

== Using Template Functions

To use a template function, include it as a string in the application.
A simple example is using a boolean [custom entitlement field](/vendor/entitlements/custom-entitlements/) to deliver a value for Max Concurrent Users.
This value should be available as an environment variable in a pod.

Given the custom license field named `max_concurrent_users`, this value can be supplied to the pod environment variable like this:

[source,YAML]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  selector:
    matchLabels:
      app: api
  template:
    spec:
      containers:
      - image: myapp/api:v1.0.1
        name: api
        env:
          - name: MAX_CONCURRENT_USERS
            value: 'repl{{ LicenseFieldValue "max_concurrent_users" }}'
----

== About `{{repl` vs `repl{{`

The template function syntax supports delimiters of either `{{repl ...}}` or `repl{{ ... }}`.
These are functionally equivalent and both are supported by the KOTS runtime.

However, `{{` is not a valid string beginning in YAML, so to use `{{repl` as the only part of a value, it's required that the YAML attribute be surrounded by quotes.
For example:

[source,YAML]
----
env:
  - name: MAX_CONCURRENT_USERS
    value: '{{repl LicenseFieldValue "max_concurrent_users"}}'
----

This solution is readable and works well for string values. The surrounding `'` characters allow this to be parsed and will render as:
[source,YAML]
----
env:
  - name: MAX_CONCURRENT_USERS
    value: '100'
----

But some Kubernetes API fields require integer values, not strings. For example, replica count. **The following YAML is not valid**:

[source,YAML]
----
replicas: '{{repl ConfigOption "replicas"}}'
----

This is invalid because it will render as:
[source,YAML]
----
replicas: '5'
----

And the Kubernetes API will reject a string value in this position.

To solve this, reverse the delimiter in the template function and remove the surrounding quotes:

```yaml
replicas: repl{{ ConfigOption "replicas" }}
```

Because this doesn't have surrounding quotes and is valid YAML, this will render as:
[source,YAML]
----
replicas: 5
----

And Kubernetes will be able to handle this.

== Using Variables in Templates

A result returned from a template function can be assigned to a variable, and the variable can be used in another template function as long as the templates are evaluated at the same time.
All application YAML documents are templated in a single pass.

The application [Config file](/reference/v1beta1/config/) is an exception.
Each config item is templated separately and has no access to variables created in other config items.
As a workaround, a hidden config item can be used to evaluate complex templates and render the results.
The result can be accessed using the [ConfigOption](/reference/template-functions/config-context/#configoption) function.

=== Generating TLS certs and keys example

This example demonstrates how to generate a CA, a cert, and a key using http://masterminds.github.io/sprig/[Sprig] functions.
`tls_json` is the hidden config item that contains all of the generated values in JSON format.

{{< warning title="Prerequisite" >}}
* This requires KOTS 1.26.0 or later.
* Default values are treated as ephemeral. The following certificate chain is recalculated each time the application configuration is modified. Be sure that your application can handle updating these parameters dynamically.
{{< /warning >}}

[source,YAML]
----
apiVersion: kots.io/v1beta1
kind: Config
metadata:
  name: config-sample
spec:
  groups:
    - name: example_settings
      title: My Example Config
      items:
        - name: ingress_hostname
          title: Ingress Hostname
          help_text: Enter a DNS hostname to use as the cert's CN.
          type: text
        - name: tls_json
          title: TLS JSON
          type: textarea
          hidden: true
          default: |-
            repl{{ $ca := genCA (ConfigOption "ingress_hostname") 365 }}
            repl{{ $tls := dict "ca" $ca }}
            repl{{ $cert := genSignedCert (ConfigOption "ingress_hostname") (list ) (list (ConfigOption "ingress_hostname")) 365 $ca }}
            repl{{ $_ := set $tls "cert" $cert }}
            repl{{ toJson $tls }}
        - name: tls_ca
          title: Signing Authority
          type: textarea
          default: repl{{ fromJson (ConfigOption "tls_json") | dig "ca" "Cert" "" }}
        - name: tls_cert
          title: TLS Cert
          type: textarea
          default: repl{{ fromJson (ConfigOption "tls_json") | dig "cert" "Cert" "" }}
        - name: tls_key
          title: TLS Key
          type: textarea
          default: repl{{ fromJson (ConfigOption "tls_json") | dig "cert" "Key" "" }}
----

= Including and excluding Kubernetes resources

Often, Vendors need a way to optionally install resources depending on customers configuration choices. A common example is giving the customer the choice to install a new database or use an existing database.

In this scenario, when a customer chooses to bring their own database, it is not desireable to deploy the optional database resources (StatefulSet, Service, etc.). This means that the customer-supplied configuration input values may result in optional Kubernetes manifests that should not be installed.

To provide optional resource installation, KOTS uses [annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/) and [template functions](/reference/template-functions/) to conditionally include or exclude resources.


== KOTS Annotations

=== Placeholder Annotation

`kots.io/placeholder '<bool>' '<string>'`

KOTS uses placeholder annotations as a way to provide an annotation that may not appear in the final rendered YAML.

Use case: providing custom Ingress annotations for a customer-provided Ingress controller.

When the placeholder evaluates to `true`, it will be replaced with the value of the desired annotation in the final rendered YAML.

When the placeholder evaluates to `false`, the annotation will not appear at all in the final rendered YAML.

[source,YAML]
----
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-annotation
  annotations:
    kots.io/placeholder: repl{{ printf "'true'" }}repl{{ printf "'my.custom/annotation.class: somevalue'" | nindent 4 }}
----

will result in the final rendered YAML:

[source,YAML]
----
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-annotation
  annotations:
    my.custom/annotation.class: somevalue
----

Similarly:

[source,YAML]
----
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-annotation
  annotations:
    kots.io/placeholder: repl{{ printf "'false'" }}repl{{ printf "'my.custom/annotation.class: somevalue'" | nindent 4 }}
----

will result in no annotations appearing in the final rendered YAML:

[source,YAML]
----
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-annotation
  annotations:
----

NOTE: By default, if neither `kots.io/exclude` nor `kots.io/when` annotations are present on a resource, the resource will be included.

Only one of the following annotations can be present on a resource. If both are present, the `kots.io/exclude` annotation will be applied, and the `kots.io/when` annotation will be ignored.

=== Exclude A Resource

`kots.io/exclude: '<bool>'`

When this annotation is present on a resource and evaluates to `'true'`, the resource will not be included in the `kustomization.yaml` file and will not be written to disk.

NOTE: Kubernetes annotations cannot be booleans and must be strings, so make sure to quote this!

.Example

The following example WILL NOT include the postgres StatefulSet when the user has not selected the `install_postgres` checkbox.

[source,YAML]
----
apiVersion: apps/v1
kind: Statefulset
metadata:
  name: postgresql
  annotations:
    "kots.io/exclude": '{{repl ConfigOptionEquals "install_postgres" "0" }}'
  labels:
    app: postgresql
spec:
  selector:
    matchLabels:
      app: postgresql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: postgresql
    spec:
      containers:
      - name: postgresql
        image: "postgres:9.6"
        imagePullPolicy: ""
...
----

=== Include A Resource
`kots.io/when: '<bool>'`

When this annotation is present on a resource and evaluates to `'false'`, the resource will not be included in the kustomization.yaml file and will not be written to disk.

NOTE: Kubernetes annotations cannot be booleans and must be strings, so make sure to quote this.

.Example

The following example WILL include the postgres StatefulSet when the user has selected the `install_postgres` checkbox.

[source,YAML]
----
apiVersion: apps/v1
kind: Statefulset
metadata:
  name: postgresql
  annotations:
    "kots.io/when": '{{repl ConfigOptionEquals "install_postgres" "1" }}'
  labels:
    app: postgresql
spec:
  selector:
    matchLabels:
      app: postgresql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: postgresql
    spec:
      containers:
      - name: postgresql
        image: "postgres:9.6"
        imagePullPolicy: ""
...
----
