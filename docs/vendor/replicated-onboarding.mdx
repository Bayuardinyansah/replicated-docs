import AboutPreflightsSupportBundles from "../partials/preflights/_overview.mdx"
import CreateRelease from "../partials/getting-started/_create-promote-release.mdx"
import DependencyYaml from "../partials/replicated-sdk/_dependency-yaml.mdx"
import EmbeddedConfig from "../partials/embedded-cluster/_default-config.mdx"
import HelmPackage from "../partials/helm/_helm-package.mdx"
import Requirements from "../partials/embedded-cluster/_requirements.mdx"
import SDKOverview from "../partials/replicated-sdk/_overview.mdx"
import TestYourChanges from "../partials/getting-started/_test-your-changes.mdx"
import UnauthorizedError from "../partials/replicated-sdk/_401-unauthorized.mdx"

# Replicated Onboarding 

This topic describes how to onboard applications to support installation with both the Replicated Embedded Cluster installer and the Helm CLI.

## Before You Begin

This section includes guidance and prerequisites to review before you begin onboarding your application.

### Prerequisites

* Create an account in the Vendor Portal. You can either create a new team or join an existing team. For more information, see [Creating a Vendor Account](vendor-portal-creating-account).

* Install the Replicated CLI. See [Installing the Replicated CLI](/reference/replicated-cli-installing).

* Complete a basic quick start workflow to create an application with a sample Helm chart and then promote and install releases in a development environment. This helps you get familiar with the process of creating, installing, and updating releases in the Replicated Platform. See [Replicated Quick Start](/vendor/quick-start-embedded).

* Ensure that you have kubectl access to a Kubernetes cluster. You can use any cloud provider or tool that you prefer to create a cluster, such as [Replicated Compatibility Matrix](/vendor/testing-how-to), Google Kubernetes Engine (GKE), or minikube.

* Ensure that you have access to a VM that meets the requirements for Embedded Cluster:

  <Requirements/>

### Best Practices and Recommendations

The following are some best practices and recommendations for successfully onboarding with Replicated:

* When integrating new Replicated features with an application, make changes in small iterations and test frequently by installing or upgrading the application in a development environment. This will help you to more easily identify issues and troubleshoot.

* Use the Replicated CLI to create and manage your application and releases. Getting familiar with the Replicated CLI will help later on when integrating Replicated workflows into your CI/CD pipelines. For more information, see [Installing the Replicated CLI](/reference/replicated-cli-installing).

* Ask for help from the Replicated community. For more information, see [Get Help from the Community](#get-help-from-the-community).

### Getting Help from the Community

The [Replicated community site](https://community.replicated.com/) is a forum where Replicated team members and users can post questions and answers related to working with the Replicated Platform. It is designed to help Replicated users troubleshoot and learn more about common tasks involved with distributing, installing, observing, and supporting their application. 

Before posting in the community site, use the search to find existing knowledge base articles related to your question. If you are not able to find an existing article that addresses your question, create a new topic or add a reply to an existing topic so that a member of the Replicated community or team can respond.

To search and participate in the Replicated community, see https://community.replicated.com/.

## Onboard

Complete the tasks in this section to onboard your application. When you are done, you can continue to [Next Steps](#next-steps) to integrate other Replicated features with your application.

### Task 1: Create An Application

To get started with onboarding, first create a new application. This will be the official Vendor Portal application used by your team to create and promote both internal and customer-facing releases.

To create an application:

1. Create a new application using the Replicated CLI or the Vendor Portal. For the application name, use an official name for your application. You will not be able to modify the name. See [Create an Application](/vendor/vendor-portal-manage-app#create-an-application).

1. Set the `REPLICATED_APP` environment variable to the unique slug of the application that you created. See [Set Environment Variables](/reference/replicated-cli-installing#replicated_app) in _Installing the Replicated CLI_. For example:

   ```bash
   export REPLICATED_APP=my-app
   ```

### Task 2: Connect Your Image Registry

Add credentials for your image registry to the Vendor Portal. This will allow you to enable the Replicated proxy service in a later step so that you can grant proxy access to application images without exposing registry credentials to your customers.

For more information, see [Connecting to an External Registry](/vendor/packaging-private-images).

### Task 3: Add the Replicated SDK and Package your Chart

Next, add the Replicated SDK as a dependency of your Helm chart then package the chart as a `.tgz` archive.

The Replicated SDK is a Helm chart that can be installed as a small service alongside your application. The SDK provides access to key Replicated functionality, including an in-cluster API and automatic access to insights and operational telemetry for instances running in customer environments. For more information, see [About the Replicated SDK](/vendor/replicated-sdk-overview).

To package your Helm chart with the Replicated SDK:

1. Go to the local directory where your Helm chart is.

1. In your application Helm chart `Chart.yaml` file, add the YAML below to declare the SDK as a dependency. If your application is installed as multiple charts, declare the SDK as a dependency of the chart that customers install first. Do not declare the SDK in more than one chart. For more information, see [Packaging a Helm Chart for a Release](helm-install-release).

   <DependencyYaml/>   

1. Update dependencies and package the chart as a `.tgz` file:

    <HelmPackage/>

    <UnauthorizedError/>

1. If your application is deployed as multiple Helm charts, package each chart as a separate `.tgz` archive using the `helm package -u PATH_TO_CHART` command. Do not declare the SDK in more than one chart.

### Task 4: Create and Install the Initial Release {#first-release}

After packaging your Helm chart, you can create a release. The initial release for your application will include the minimum files required to install a Helm chart with Embedded Cluster:
* The Helm chart `.tgz` archive
* [KOTS HelmChart custom resource](/reference/custom-resource-helmchart-v2)
* [Embedded Cluster Config](/reference/embedded-config)

If you have multiple charts, you will add each chart archive to the release, plus a corresponding KOTS HelmChart custom resource for each archive.

To create the first release for your application:

1. In the local directory for your Helm chart, create a subdirectory named `manifests` where you will add the files for the release.

1. In the `manifests` directory:

   1. Move the `.tgz` chart archive that you packaged. If your application is deployed as multiple Helm charts, move each `.tgz` archive to `manifests`.

   1. Create an `embedded-cluster.yaml` file with the following default Embedded Cluster Config:

      <EmbeddedConfig/>
    
      For more information, see [Using Embedded Cluster](/vendor/embedded-overview).

   1. Create a new YAML file. In this file, configure the KOTS HelmChart custom resource by completing the workflow in [Configuring the HelmChart Custom Resource](helm-native-v2-using).
   
      The KOTS HelmChart custom resource is required to install Helm charts with KOTS and Embedded Cluster. As part of configuring the KOTS HelmChart custom resource, you will rewrite image names and add image pull secrets to enable the Replicated proxy service.

   1. If your application is deployed as multiple Helm charts, repeat the step above to add a separate HelmChart custom resource for each Helm chart archive in the release.

1. From the `manifests` directory, create a release and promote it to the Unstable channel. For more information, see [Managing Releases with the Vendor Portal](releases-creating-releases) or [Managing Releases with the CLI](releases-creating-cli).

    ```bash
    replicated release create --yaml-dir . --promote Unstable
    ```

1. Install the release in your development environment to test:

   1. Install with Embedded Cluster on a VM. See [Download the Embedded Cluster Binary](/vendor/embedded-overview#download-the-embedded-cluster-binary) and [Install](/vendor/embedded-overview#install) in _Using Embedded Cluster_.

   1. Install in an existing cluster with KOTS. See [Online Installation in Existing Clusters](/enterprise/installing-existing-cluster).

After successfully installing the initial release both on a VM and in an existing cluster, go to the next task. You will continue to iterate throughout the rest of the onboarding process by creating and promoting new releases, then upgrading to the new version in your development environment.

### Task 5: Customize the KOTS Admin Console {#admin-console}

Configure the KOTS Application custom resource to add an application name, icon, and status informers. The name and icon will be displayed in the Admin Console and the Replicated Download Portal. The status informers will be used to display the application status on the Admin Console dashboard.

To configure the KOTS Application custom resource:

1. In your `manifests` directory, create a new `kots-app.yaml` file.

1. In the `kots-app.yaml` file, add the [KOTS Application](/reference/custom-resource-application) custom resource YAML and set the `title`, `icon`, and `statusInformers` fields.

   **Example:**

    ```yaml
    apiVersion: kots.io/v1beta1
    kind: Application
    metadata:
      name: gitea
    spec:
      title: Gitea
      icon: https://raw.githubusercontent.com/cncf/artwork/master/projects/kubernetes/icon/color/kubernetes-icon-color.png
      statusInformers:
        - deployment/gitea
    ```
    For more information, see:
    * [Customizing the Application Icon](/vendor/admin-console-customize-app-icon)
    * [Enabling and Understanding Application Status](/vendor/insights-app-status)
    * [Application](/reference/custom-resource-application)

1. <CreateRelease/>

1. <TestYourChanges/>

### Task 6: Set Up the Admin Console Config Screen and Map to Helm Values

The KOTS Admin Console config screen is used to collect required and optional application configuration values from your users. User-supplied values provided on the config screen can be mapped to your Helm values.

:::note
Before you begin this task, you can complete the [Set Helm Values with KOTS](/vendor/tutorial-config-setup) tutorial to learn how to map user-supplied values from the Admin Console config screen to a Helm chart.
:::

To set up the Admin Console Config screen for your application:

1. In your `manifests` directory, create a new file named `kots-config.yaml`.

1. In `kots-config.yaml`, add the KOTS Config custom resource. Configure the KOTS Config custom resource based on the values that you need to collect from users.

    **Example:**

    ```yaml
    apiVersion: kots.io/v1beta1
    kind: Config
    metadata:
      name: my-application
    spec:
      groups:
        - name: example_group
          title: Example Group
          items:
            - name: example_item
              title: Example Item
              type: text
              default: "Hello World"
    ```

    For more information, see:
    * [Creating and Editing Configuration Fields](/vendor/admin-console-customize-config-screen) 
    * [Using Conditional Statements in Configuration Fields](/vendor/config-screen-conditional)  
    * [Config](/reference/custom-resource-config)  

1. <CreateRelease/>

1. <TestYourChanges/>

1. In `manifests`, open the KOTS HelmChart custom resource that you configured in a previous step. Configure the `values` key of the HelmChart custom resource to map the fields in the KOTS Config custom resource to your Helm values.

   For more information, see:
   * [Mapping User-Supplied Values](/vendor/config-screen-map-inputs)
   * [Tutorial: Set Helm Chart Values with KOTS](/vendor/tutorial-config-setup)
   * [`values`](/reference/custom-resource-helmchart-v2#values) in _HelmChart v2_

1. <CreateRelease/>

1. <TestYourChanges/>

1. Continue to create and test new releases with new config fields until you are ready to move on to the next task.

### Task 7: Define Preflight Checks

In the next two tasks, you will add specs for _preflight checks_ and _support bundles_.

<AboutPreflightsSupportBundles/>

:::note
Before you begin this task, Replicated recommends that you complete the [Add Preflight Checks to a Helm Chart](/vendor/tutorial-preflight-helm-setup) tutorial to learn how to add a preflight spec to a Helm chart in a Kubernetes secret, then run the preflight checks before installation.
:::

To define preflight checks for your application:

1. In your Helm chart `templates` directory, add a Kubernetes Secret that includes a preflight spec. For more information, see [Defining Preflight Checks](/vendor/preflight-defining).
     :::note
     If your application is deployed as multiple Helm charts, add the Secret to the `templates` directory for the chart that is installed first.
     :::

1. Update dependencies and package the chart as a `.tgz` file:

   <HelmPackage/>

1. Move the `.tgz` file to the `manifests` directory.

1. <CreateRelease/>

1. Install the release to test your changes.

    Preflight checks run automatically during installation.

1. Continue to create and test new releases with additional preflight checks until you are ready to move on to the next task.

### Task 8: Add a Support Bundle Spec

To add the default support bundle spec to your application:

1. In your Helm chart `templates` directory, add the following YAML to a Kubernetes Secret to enable the default support bundle spec for your application:

    ```yaml
    apiVersion: v1
    kind: Secret
    metadata:
      labels:
        troubleshoot.sh/kind: support-bundle
      name: example
    stringData:
      support-bundle-spec: |
        apiVersion: troubleshoot.sh/v1beta2
        kind: SupportBundle
        metadata:
          name: support-bundle
        spec:
          collectors: []
          analyzers: []
    ```
   
1. (Recommended) At a minimum, Replicated recommends that all support bundle specs include the `logs` collector. This collects logs from running Pods in the cluster.

   ```yaml
   apiVersion: v1
   kind: Secret
   metadata:
     name: example
     labels:
       troubleshoot.sh/kind: support-bundle
   stringData: 
     support-bundle-spec: |-
       apiVersion: troubleshoot.sh/v1beta2
       kind: SupportBundle
       metadata:
         name: example
       spec:
         collectors:
           - logs:
               selector:
                 - app.kubernetes.io/name=myapp
               namespace: {{ .Release.Namespace }}
               limits:
                 maxAge: 720h
                 maxLines: 10000
   ```

   For more information, see:
   * <a href="/vendor/support-bundle-customizing">Adding and Customizing Support Bundles</a>
   * [Pod Logs](https://troubleshoot.sh/docs/collect/logs/) in the Troubleshoot documentation.

1. (Recommended) Ensure that any preflight checks that you added are also include in your support bundle spec. This ensures that support bundles collect at least the same information collected when running preflight checks. 

1. Update dependencies and package the chart as a `.tgz` file:

   <HelmPackage/>

1. Move the `.tgz` file to the `manifests` directory.

1. <CreateRelease/>

1. Install the release to test your changes. For information about how to create support bundles, see [Generating Support Bundles](/vendor/support-bundle-generating).

1. (Optional) Customize the support bundle spec by adding additional collectors and analyzers. You can do this step later. See [(Optional) Customize the Specification](/vendor/support-bundle-customizing#optional-customize-the-specification) in _Adding and Customizing Support Bundles_.

### Task 9: Alias Replicated Endpoints with Your Own Domains

Replicated recommends that you use custom domains to alias Replicated endpoints. Replicated domains are external to your domain and can require additional security reviews by your customer. Using custom domains as aliases can bring the domains inside an existing security review and reduce your exposure.

For more information, see [Using Custom Domains](/vendor/custom-domains-using).

## Next Steps

After completing the main onboarding tasks, Replicated recommends that you also complete the following additional tasks to integrate other Replicated features with your application. You can complete these next recommended tasks in any order.

### Add Support for Helm Installations

Existing KOTS releases that include one or more Helm charts can be installed with the Helm CLI; it is not necessary to create and manage separate releases or channels for each installation method. To enable Helm installations for Helm charts distributed with Replicated, the only extra step is to add a Secret to your chart to authenticate with the Replicated proxy service.  

:::note
Before you test Helm installations for your application, you can complete the [Deploy a Helm Chart with KOTS and the Helm CLI](tutorial-kots-helm-setup) tutorial to learn how to install a single release with both KOTS and Helm.
:::

To support and test Helm installations:

1. Follow the steps in [Using the Proxy Service with Helm Installations](/vendor/helm-image-registry) to authenticate with the Replicated proxy service by creating a Secret with `type: kubernetes.io/dockerconfigjson` in your Helm chart.

1. Update dependencies and package the chart as a `.tgz` file:

    <HelmPackage/>

1. Add the `.tgz` file to a release. For more information, see [Managing Releases with the Vendor Portal](releases-creating-releases) or [Managing Releases with the CLI](releases-creating-cli).

1. Install the release with the Helm CLI to test your changes. For more information, see [Installing with Helm](/vendor/install-with-helm).

### Add Support for Air Gap Installations

KOTS and Embedded Cluster support installations in _air gap_ environments with no outbound internet access. Users can install in air gap environments by providing air gap bundles that contain the required images.

You can use the Vendor Portal to build and download the air gap bundles needed to install in an air gap existing cluster with KOTS or in an air gap VM or bare metal server with Embedded Cluster.

To add support for air gap installations:

1. If there are any images for your application that are not listed in your Helm chart, list these images in the `additionalImages` attribute of the KOTS Application custom resource. This ensures that the images are included in the `.airgap` bundle for the release. See [Define Additional Images](/vendor/operator-defining-additional-images).

1. If you have any Helm values that determine whether or not an application image is included in an installation, then configure the `builder` key in the KOTS HelmChart custom resource to enable those values. The Vendor Portal uses the values provided in the `builder` key to build the `.airgap` bundle for the release. See [Packaging Air Gap Bundles for Helm Charts](/vendor/helm-packaging-airgap-bundles).

    :::note
    If the default values in your Helm chart already enable all the images needed to successfully deploy the chart, then you do not need to configure the `builder` key.
    :::

1. If you have not done so already as part of [Task 4: Create and Install the Initial Release](#first-release), ensure that the `values` key in the KOTS HelmChart custom resource correctly rewrites image names for air gap installations. See [Rewrite Image Names](/vendor/helm-native-v2-using#rewrite-image-names) in _Configuring the HelmChart Custom Resource v2_.

1. Create a customer with the **Airgap Download Enabled** entitlement enabled so that you can test air gap installations. See [Creating and Managing Customers](/vendor/releases-creating-customer).

1. Download the Embedded Cluster release artifacts for air gap installations, then install with Embedded Cluster on an air gap VM to test. See [Installing in Air Gap Environments with Embedded Cluster](/enterprise/installing-embedded-air-gap).

1. Download the `.airgap` bundle for the release and the air gap bundle for the KOTS Admin Console. You can also download both bundles from the Download Portal for the target customer. See [Building Air Gap Bundles](/vendor/releases-download-airgap-bundles). Then, install in an air gap existing cluster to test. See [Air Gap Installation in Existing Clusters](/enterprise/installing-existing-cluster-airgapped).

### Add Application Links to the Admin Console Dashboard

You can add the Kubernetes SIG Application custom resource in order to add a link to your application from the Admin Console dashboard. This makes it easier for users to access your application after installation.

For more information, see [Adding Application Links to the Dashboard](/vendor/admin-console-adding-buttons-links).

### Update the Preflight and Support Bundles Specs

After adding basic specs for preflights and support bundles, you can continue to add more collectors and analyzers as needed.

Consider the following recommendations and best practices:

* Revisit your preflight and support bundle specs when new support issues arise that are not covered by your existing specs.

* Your support bundles should include all of the same collectors and analyzers that are in your preflight checks. This ensures that support bundles include all the necessary troubleshooting information, including any failures in preflight checks.

* Your support bundles will most likely need to include other collectors and analyzers that are not in your preflight checks. This is because some of the information used for troubleshooting (such as logs) is not necessary when running preflight checks before installation.

The documentation for the open-source Troubleshoot project includes the full list of available collectors and analyzers that you can use. See [All Collectors](https://troubleshoot.sh/docs/collect/all/) and the [Analyze](https://troubleshoot.sh/docs/analyze/) section in the Troubleshoot documentation.

You can also view common examples of collectors and analyzers used in preflight checks and support bundles in [Preflight Spec Examples](preflight-examples) and [Support Bundle Spec Examples](support-bundle-examples).

### Add and Query Custom License Entitlements

You can add custom license entitlements for your application in the Vendor Portal. Custom license fields are useful when there is entitlement information that applies to a subset of customers. For example, you can create a custom license field to limit the number of active users permitted. Or, you can create a field that limits the number of nodes a customer is permitted on their cluster.

After you add custom entitlements, you can also add logic to your application to query license entitlements both before deployment and at runtime.

For more information, see:
* [Managing Custom License Fields](/vendor/licenses-adding-custom-fields)
* [Querying Entitlements with the Replicated SDK API](/vendor/licenses-reference-sdk)
* [Checking Entitlements in Preflights with KOTS Template Functions](/vendor/licenses-referencing-fields)
* [Verifying License Field Signatures with the Replicated SDK API](/vendor/licenses-verify-fields-sdk-api)
* [Creating and Managing Customers](/vendor/releases-creating-customer)
* [Developing Against the SDK API](/vendor/replicated-sdk-development)

### Configure Backup and Restore

Enable backup and restore with Velero for your application so that users can back up and restore their KOTS Admin Console and application data. 

There are different steps to configure backup and restore for Embedded Cluster and for existing cluster installations with KOTS:
* To configure the disaster recovery feature for Embedded Cluster, see [Disaster Recovery for Embedded Cluster](/vendor/embedded-disaster-recovery)
* To configure the snapshots feature for existing cluster KOTS installations, see [Configuring Backup and Restore](snapshots-configuring-backups).

### Add Custom Metrics

In addition to the built-in insights displayed in the Vendor Portal by default (such as uptime and time to install), you can also configure custom metrics to measure instances of your application running customer environments. Custom metrics can be collected for application instances running in online or air gap environments using the Replicated SDK.

For more information, see [Configuring Custom Metrics](/vendor/custom-metrics).

### Integrate with CI/CD

Replicated recommends that teams integrate the Replicated Platform into their existing develeopment and production CI/CD workflows. This can be useful for automating the processes of creating new releases, promoting releases, and testing releases with the Replicated Compatibility Matrix.

For more information, see:
* [About Integrating with CI/CD](/vendor/ci-overview)
* [About Compatibility Matrix](/vendor/testing-about)
* [Recommended CI/CD Workflows](/vendor/ci-workflows)

### Customize Release Channels

By default, the Vendor Portal includes Unstable, Beta, and Stable channels. You can customize the channels in the Vendor Portal based on your application needs.

Consider the following recommendations:
* Use the Stable channel for your primary release cadence. Releases should be promoted to the Stable channel only as frequently as your average customer can consume new releases. Typically, this is no more than monthly. However, this cadence varies depending on the customer base.
* If you have a SaaS product, you might want to create an "Edge" channel where you promote the latest SaaS releases.
* You can consider a “Long Term Support” channel where you promote new releases less frequently and support those releases for longer.
* It can be useful to create channels for each feature branch so that internal teams reviewing a PR can easily get the installation artifacts as well as review the code. You can automate channel creation as part of a pipeline or Makefile.

For more information, see:
* [About Channels and Releases](releases-about-releases)
* [Creating and Editing Channels](/vendor/releases-creating-channels)